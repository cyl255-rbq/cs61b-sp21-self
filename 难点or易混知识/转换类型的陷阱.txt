public class A {
	public void m2() { System.out.println("Am2-> " + this.x); }
}
public class C extends A {
	public void m2() { System.out.println("Cm2-> " + super.x); }
 }
public class D {
	public static void main (String[] args) {
		A c0 = new C();
		(C) c0.m2();
	}
}
这是一个**优先级（Precedence）**问题。
在 Java 中，点操作符 . 的优先级 高于 强制类型转换 (Type)。
所以编译器会这样解析这行代码：(C) (c0.m2())。
    先执行 c0.m2()。这个方法返回 void。
    然后试图把 void 强转成 C 类型。
千万别写 super.super（Java 没这功能）。
强转调用方法一定要加括号：((Dog) a).bark() 是对的，(Dog) a.bark() 是错的。

((Dog) a).play(12);（这里a的是Animal类，存的是Cat）
让我们像慢动作回放一样，拆解 ((Dog) a).play(12); 这行代码在运行时的执行步骤：
第一步：身份核查（Casting）—— 崩在这里！
代码执行时，Java 虚拟机（JVM）读到 (Dog) a。 它的内心活动是这样的：
    JVM: “主人让我把变量 a 强转成 Dog 类型。”
    JVM: “那我得去内存里看看，这个 a 指向的那个真实对象，到底是不是狗（或者狗的子孙）？”
    检查结果: “我看了一眼内存，这个对象是 Cat（Garfield）。”
    逻辑判断: “猫 是 狗吗？显然不是。”
    结果: 直接抛出 ClassCastException 异常，程序当场死亡。
第二步：找方法（Method Lookup）—— 根本没机会执行
你说的“去 Cat 里找 play 方法”，是第二步才会发生的事情。 但因为第一步（强转）已经报错崩溃了，计算机根本就没有机会走到第二步去查找方法。
运行时错误的原因只有一个： “猫不能变狗”。
    编译时：编译器只看你写的 (Dog)，它信了你的鬼话，以为这真的是狗，所以让你通过。
    运行时：Java 很诚实，它在做任何动作之前，会先检查：“你把这玩意儿当狗用，可它本质上是一只猫啊！” 然后直接拒绝执行。
记住这个铁律： 兄弟类之间（Cat 和 Dog）永远不能互相强转，一转就崩。 只有父子之间（Animal 转 Dog，且本质确实是 Dog）才能转。

有class C extend A
A a2=new A();
((C) a2).m2();
会先哦让他通过，你说是C就是吧，然后去看a2指的对象，如果a2指的是C那就可以，不是，那就报错
上面的cat dog也是，编译通过后去看指向，指的是cat而不是dog，所以报错
所以，强转（Casting）能不能成功，完全取决于：被转换对象创建时 new 后面那个东西到底是谁。只要本质是对的，怎么转都行
并且，因为强转能不能要看对象的指向，所以看内容了，所以是运行时报错

因为在 Java（以及大多数编程语言）中，强制类型转换 (Type) 的优先级 比 除法 / 要高。
你写的 (double) 2 / 3
(double) 紧紧吸住了它右边的第一个数字 2。
所以是0.6666666666666666
(double) (2 / 3)的结果是0