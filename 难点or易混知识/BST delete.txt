    //主要思想是什么呢，就是说递归，返回删除后的节点，你要接住所以这里是return node.left，就是层层递归回去
    private Node delete(Node node, Key key) {
        if (node == null) return null;

        int cmp = key.compareTo(node.key);
        if      (cmp < 0) node.left  = delete(node.left,  key);
        else if (cmp > 0) node.right = delete(node.right, key);
        else {
            if (node.right == null) return node.left;//解决了链接0个/1个的情况，如果0个则null,1个则返回另一边的节点
            if (node.left  == null) return node.right;
            Node temp = node;
            node = min(temp.right);
            node.right = deleteMin(temp.right);
            node.left = temp.left;
        }
        node.size = size(node.left) + size(node.right) + 1;
        return node;
    }
    //返回删除最小节点后的节点
    private Node deleteMin(Node node) {
        if (node.left == null) return node.right;
        node.left = deleteMin(node.left);
        node.size = size(node.left) + size(node.right) + 1;
        return node;
    }
    //找到右边最小的
    private Node min(Node node) {
        if (node.left == null) return node;
        else                   return min(node.left);
    }

为什么要“重新赋值” (node.left = ...)，而不是像 get 方法那样直接“传递结果” (return ...)？
如果不写成 node.left = deleteMin(node.left) 而写成 return deleteMin(node.left)，你的树会瞬间崩塌，只剩下一个残缺的零件。
// ❌ 错误的写法
private Node deleteMin(Node node) {
    if (node.left == null) return node.right; // Base case
    // 这里直接返回下层的结果，不保留自己
    return deleteMin(node.left); 
}
最终结果：整棵树被你删光了
正确的写法 (指针重连 / x = change(x))
什么时候用哪种？
这是递归里的一个黄金法则：
    只读操作 (get, search, size):
        你只是想从底下拿个信息上来。
        用 return helper(node.left)。
        比喻：接力赛，最后一棒跑到终点就行。
    修改/破坏结构操作 (put, remove, deleteMin):
        因为底下的结构变了，你必须重新维护这种连接关系。
        用 node.left = helper(node.left); return node;。
        比喻：修整链条。我要把坏掉的那一环修好，但我必须紧紧抓住修好后的那一环，并且我自己也不能松手，否则整个链条就断了。


这是一个非常深刻的问题，它触及了 Java 语言的核心机制：值传递（Pass by Value） 以及 递归修改数据结构的标准范式。
如果不写成 private Node delete(...) 而写成 private void delete(...)，你会发现你永远无法删除叶子节点，或者无法正确断开父子关系。
我用两个核心理由来解释为什么必须返回 Node。
理由一：Java 的“复印件”陷阱
在 Java 中，当你把一个对象传给函数时，你传的不是对象本身，而是对象引用的复印件。
1. 假如我们要删除叶子节点 A
想象树结构是：Parent -> A。
2. 错误的写法 (void 方式)
Java
// ❌ 假设这是 void 写法
private void delete(Node node, Key key) {
    // 假设我们找到了要删的节点 A，此时 node 就指向 A
    if (key.equals(node.key)) {
        // 你想把 A 删掉，于是你写：
        node = null; 
        return;
    }
    // ... 递归逻辑 ...
}
发生了什么？
    你调用 delete(A)。
    Java 复制了一个 node 变量，它指向内存里的 A。
    你执行 node = null。
    结果： 你只是把函数内部的这个 node 变量（复印件）撕了。
    外部： Parent 依然死死地指着内存里的那个 A。树结构纹丝不动。
3. 正确的写法 (return Node 方式)
Java
// ✅ 正确的写法：x = change(x)
private Node delete(Node node, Key key) {
    if (key.equals(node.key)) {
        // 我要自杀了，我返回 null 给我的父亲
        return null; 
    }
    // ...
}
// 在上一层（Parent）里是这样调用的：
parent.left = delete(parent.left, key);
发生了什么？
    你调用 delete(A)。
    函数返回 null。
    上一层执行： parent.left = null。
    结果： Parent 的左指针真的被改成了 null。连接断开了，A 被删除了。
理由二：为了不用“向后看”（Look Ahead）
如果你非要用 void 实现删除，你就必须始终站在父亲的角度操作孩子。
1. void 写法的痛苦
为了能真的删掉节点，你不能等到进入了 delete(A) 再删，你必须在 delete(Parent) 的时候就判断：
Java
// ❌ void 写法极其痛苦，需要预判
private void delete(Node parent, Key key) {
    // 必须提前看一眼左孩子是不是要删的
    if (parent.left.key.equals(key)) {
        parent.left = null; // 在这里动手
        return;
    }
    // 必须提前看一眼右孩子是不是要删的
    if (parent.right.key.equals(key)) {
        parent.right = null;
        return;
    }
    
    // 递归下去
    if (key < parent.key) delete(parent.left, key);
}
这就带来了巨大的问题：
    根节点怎么办？ 根节点没有父亲，你需要单独写一套逻辑处理 root 的删除。
    代码丑陋： 每一层都要检查 node.left 和 node.right 还是不是 null，防止空指针。
    结构调整困难： 如果要删的节点有两个孩子（Case 3），你不仅要断开连接，还要把新节点接上去。在 void 方法里，你得操作 parent.left = successor，这需要你一直把 parent 传下去，逻辑非常混乱。
2. return Node 写法的优雅
这种写法叫 Pointer Reinforcement（指针强化/重连）。
它的逻辑是：
    “我不管你是谁，我把这个任务交给你（递归），你处理完之后，把你那边的【新根节点】返回给我，我只负责把你挂在我的左边/右边。”
Java
// ✅ 极其优雅
node.left = delete(node.left, key);
    如果 node.left 不需要变，delete 会返回它自己。
    如果 node.left 被删了，delete 会返回 null。
    如果 node.left 被它的接班人顶替了，delete 会返回那个接班人。
父节点根本不需要知道发生了什么，它只需要重新建立连接（=）即可。
总结
为什么不写成 void？
    因为 Java 是值传递：在函数里把参数设为 null 对外面没影响。你必须通过 return 把改变后的状态传回去，并在上一层赋值。
    为了解耦：父节点不需要知道子节点具体怎么变（是删了、还是换人了），父节点只管接收一个新的结果挂上去。
这句口诀请记死：“在递归修改树结构时，永远使用 x.left = change(x.left)，而不要试图在 change(x) 内部修改 x。”