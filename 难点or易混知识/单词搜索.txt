给定一个 N×N 的单词搜索问题和 N 个单词，设计一个算法在 O(N) 时间内解决该问题。为简单起见，假设没有单词包含在其他单词中，即
如果给出了单词“bear”，就不会再给出“be”。
提示：将这些单词添加到 Trie 树中，您可能会发现 longestPrefixOf 操作很有用。回顾一下，longestPrefixOf 接受一个字符串键，并返回 Trie 树中存在的该键的最长前缀，如果不存在该前缀，则返回 null。

第一步：构建 Trie 首先，将所有要查找的 N 个单词全部插入到一棵 Trie 树中。这样做的目的是为了能够快速判断棋盘上的字母序列是否匹配我们要找的单词。
第二步：遍历棋盘 遍历 N×N 矩阵中的每一个字母。我们将每一个字母都视为一个潜在单词的“起点”。
第三步：八个方向探测 对于每一个字母 (i,j)，我们需要向 8 个方向进行探测：北 (N)、东北 (NE)、东 (E)、东南 (SE)、南 (S)、西南 (SW)、西 (W)、西北 (NW)。
第四步：利用 longestPrefixOf 进行匹配 在某个方向上，我们会取出从起点开始直到矩阵边缘的字符串。例如，如果从某个字母向西有字符串 "SOHUMC"，我们调用 Trie 的 longestPrefixOf("SOHUMC")：
    如果返回了某个单词（比如 "SOHUM"），说明我们找到了一个目标词。
    由于题目假设单词之间没有嵌套关系（比如有了 "bear" 就不会有 "be"），所以只要找到了一个前缀匹配，它就一定是唯一的答案。
第五步：标记已找到 找到单词后，将其从 Trie 中移除（或标记为已找到），直到所有单词都被找齐（Trie 变为空）。

运行时分析 (Runtime)
这个 O(N^3) 的复杂度是怎么算出来的？
    棋盘格数： 矩阵共有 N×N=N^2 个格子。
    每个格子的操作：
        对于每个格子，我们要检查 8 个方向（常数项，忽略不计）。
        在每个方向上，我们调用 longestPrefixOf。这个操作的时间复杂度与输入字符串的长度成正比。
        由于矩阵是 N×N 的，任何方向上的字符串长度最大也就是 N。
    总计： N^2(格子)×N(字符串匹配操作)=O(N^3)。



如果字符串长度是 100，但 Trie 树最深只有 5 层，那我们在走到第 6 层发现没路时就停下了，实际只走了 6 步。
但在算法分析（Big-O）中，我们说 O(L) 是基于以下三个原因：
1. 扫描过程的“物理极限”
longestPrefixOf(String s) 的逻辑是：
    从字符串的第 1 个字符开始。
    在 Trie 中找对应的子节点。
    接着看第 2 个字符、第 3 个字符……直到：
        情况 A： 字符串读完了。
        情况 B： Trie 树走到头了（没路了）。
虽然在情况 B 下我们确实会提前停下来，但在**最坏情况（Worst Case）**下，我们可能需要一直读到字符串的最后一个字符才能确定结果。因此，我们用字符串长度 L 来描述这个操作的“潜力”上限。
2. O(L) vs O(Trie Depth)
在 Wordsearch 这个特定问题中：
    字符串长度 L：最大是 N（棋盘的边长）。
    Trie 深度 D：取决于你要找的单词中最长的那一个，最大也可以是 N。
既然两者的最大值都在 N 这个量级，那么说复杂度是 O(L) 或 O(N) 是最稳妥的。即使 Trie 很短（比如单词都很短），我们在 O(N3) 的分析中依然会保留 N 这个项，因为它代表了我们在棋盘上探测一个方向的最大可能性。
3. 为什么不叫 O(Trie 深度)？
通常我们习惯说“与输入字符串长度成正比”，是因为：
    输入是可见的： 当你调用函数时，字符串 s 的长度是确定的。
    安全性： O(L) 保证了无论 Trie 树多复杂，这个函数都不会超过 L 次操作。
    举个例子：
    如果你在找单词 "APPLE"，棋盘上那一串字母是 "APPROXIMATE"。
        你读 'A', 'P', 'P'……都能在 Trie 里找到。
        读到 'R' 的时候，Trie 说“我这儿没这条路”。
        你立刻停下。
        这里的开销确实是 O(4)，它既小于字符串长度 11，也小于单词长度 5。但在 Big-O 的大蓝图中，我们统一记作 O(L) 以简化计算。