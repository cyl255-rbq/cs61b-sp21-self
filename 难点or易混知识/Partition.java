/**实现 partition 函数，该函数接受一个 IntList lst 和一个整数 k，并将 lst 破坏性地划分成 k 个 IntList，使得每个列表具有以下属性：
1. 它的长度与其他列表相同。如果无法做到这一点，即列表 lst 无法被等分，则后面的列表应该比它少一个元素。
例如，使用 k = 3 对长度为 25 的 IntList 进行分区，将得到长度分别为 9、8 和 8 的分区列表。
2. 它的排序与 lst 的排序一致，即 lst 中较早的项目必须先于较晚的项目。
这些列表应该放入一个长度为 k 的数组中，并返回该数组。例如，如果列表 lst 包含元素 5、4、3、2、1，且 k = 2，那么一种可能的划分方式
（注意，存在多种可能的划分方式）是将元素 5、3、2 放在索引 0 处，将元素 4、1 放在索引 1 处。
您可以假设您拥有 reverse 方法的访问权限，该方法会破坏性地反转给定 IntList 的顺序，并返回指向反转后的 IntList 的指针。
您不能创建任何 IntList 实例。您可能不需要所有代码行.
提示：您可能会发现 % 运算符很有用。*/
public static IntList[] partition(IntList lst, int k) {
    IntList[] array = new IntList[k];
    int index = 0;
    // 【第 4 行】先把原链表彻底翻个底朝天
    IntList L = reverse(lst); 
    while (L != null) {
        IntList prevAtIndex = array[index];
        IntList next = L.rest;
        array[index] = L;
        array[index].rest = prevAtIndex;
        L = next;
        index = (index + 1) % array.length;
        //把L移到数组list的最开头，然后.rest=原来的数组，所以创建两个一个记录原理的数组，另一个记录next
    }
    return array;
}
//核心方法是把列表分成两个，用next记住剩下的，把反转后的第一个链接array[i]，然后再赋值给array[i]，然后让L为之前记住的剩下的
//接着遍历，通过index查找为第几个人这样循环
/**为了避免去维护麻烦的“尾巴指针”，这道题想利用链表的一个特性： 在头部插入（Add First）是非常简单的，不需要找尾巴。
但是，如果你直接把 1, 2, 3, 4 依次插到头部：
    拿 1，插进去 -> [1]
    拿 2，插另一个 -> [2]
    拿 3，插回第一个的头部 -> [3 -> 1] (糟糕！顺序反了！我们要的是 1->3)
✨ 解决方案：负负得正
既然“头部插入”会把顺序弄反，那我们在插入之前，先把原链表反转一次！
    原链表： 1 -> 2 -> 3 -> 4
    第 1 步（Reverse）： 变成 4 -> 3 -> 2 -> 1
    第 2 步（依次取头部插入）：
        取 4，放入 array[0] -> [4]
        取 3，放入 array[1] -> [3]
        取 2，插入 array[0] 头部 -> [2 -> 4] (看！2 在 4 前面，顺序对了！)
        取 1，插入 array[1] 头部 -> [1 -> 3] (看！1 在 3 前面，顺序对了！) */
