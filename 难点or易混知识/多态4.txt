代码场景：a.method(b)
编译时：看 a 和 b 的静态类型，彻底锁死要调用的方法签名（比如 method(Animal)）。
运行时：看 a 的动态类型，决定执行谁家定义的 method(Animal)（是爸爸定义的，还是儿子重写过的）。
关于 b：运行时，b 的动态类型不影响方法的选择，也不会导致报错（只要编译过了，它就一定是安全的）。它只是作为一个参数传进去。
并且对于b 编译的时候：只是语法上的转换（允许你写这行代码）。编译器并没有真正去动那个对象。
运行的时候：才是真正的逻辑执行。而对于对象强转来说，执行 = 检查
所以先检查b，不合格报错，运行不到调用method的时候
B x = (B) new A();，代码编译可以通过（编译器觉得既然 B 是 A 的子类，逻辑上存在转换的可能性），但运行时会直接炸掉。
报错： ClassCastException
运行上：父类对象永远不能强转成子类（除非它原本就是子类假扮的）。
Java 的点操作符 . 优先级比强转 (Type) 高。这个很重要
(A) x.f(y)和((A)x).f(y)不一样

class A{
void f(){打印1}
class B extend A{
void f(){打印2}
B a=new B
C c=new C
((A)a).f()
返回打印2，因为编译时先看class A里有无f()，然后运行时先看a是不是A，B是subclass所以是，然后看a的动态指向B，所以调用B的f()