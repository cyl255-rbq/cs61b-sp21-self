关于你的方法：拓扑排序 + 取大 (Relax Max)
你的方法是完全可行且标准的解法。事实上，这就是在 DAG（有向无环图）上求最长路径的标准动态规划（DP）解法。
你的逻辑是：
    对图进行拓扑排序。
    按照拓扑序遍历节点。
    对于每个节点，检查它的所有出边，执行 distTo[w] = max(distTo[w], distTo[v] + weight)。
这和取反的方法得到的结果是一模一样的。
为什么它们是一样的？
其实 PPT 里的 DAGSPT（DAG Shortest Path Tree）算法，其底层实现逻辑本来就是：
    拓扑排序 + 松弛操作 (Relax Min)
所以，这两种方法的区别仅仅在于数学上的等价变换：
    你的方法： 直接求 Max(正权重)。
    PPT的方法： 求 Min(负权重)，最后再取反结果。
        数学原理：max(A,B)⟺−min(−A,−B)
既然一样，为什么PPT要教“取反”这种“多此一举”的方法？
这通常是为了展示**代码复用（Code Reuse）的思想，或者是为了展示归约（Reduction）**的概念：
    如果你已经写好了一个求“最短路径”的函数库（Library）。
    你碰到了一个“最长路径”的问题。
    作为程序员，最快的方法不是重写一遍逻辑把 < 改成 >，而是直接把数据“取反”丢进现有的函数里。
    这就是图片底部字幕说的“非常巧妙”的地方——巧妙在转化问题，而不是算法本身更优。



你之所以觉得困惑，是因为你潜意识里在拿它和 Dijkstra 做比较。Dijkstra 是“贪心算法”，而你现在用的“拓扑排序+取大”本质上是 动态规划 (Dynamic Programming)。
之所以你的方法（拓扑排序+取大）在 DAG 上求最长路径（哪怕有负权）绝对可行，核心原因就两个字：顺序。
以下是详细的逻辑拆解：
1. 核心原理：确定的“过去” (The Guarantee)
拓扑排序的定义决定了：对于任何一条边 u→v，节点 u 在序列中一定出现在 v 之前。
这意味着当你按照拓扑顺序遍历到节点 v 时：
    所有能通向 v 的“上游节点”（比如 u1​,u2​,…）都已经全部被处理过了。
    这些上游节点的最长路径值（dist[u]）此刻已经是最终定案（Finalized）的，绝对不会再变了。
    因为没有环（DAG），所以未来处理的节点绝不可能再绕回来改变 v 的值。
比喻： 这就好比长江的水流。你想计算下游某个监测点的最大流量。
    拓扑排序保证了你是由上游往下游走的。
    当你走到下游某点 v 时，所有上游支流的水量都已经算好了。
    你只需要把所有汇入 v 的支流加起来（或取最大值），那就是 v 的最终结果。你不需要担心“是不是下游有条河会倒流回上游”，因为是 DAG（无环）。
2. 为什么 Dijkstra 做不到？
Dijkstra 失败的原因是它没有这个“顺序保证”：
    Dijkstra 是基于贪心的：它认为“当前离起点最近的点”就是定案的点。
    在求最长路径时（尤其是正权图），“当前最长的路”未必是最终最长的路（因为后面可能还有更长的正权边加进来）。
    在有负权边时，Dijkstra 的贪心假设更是直接崩溃。
3. 本质是动态规划 (DP)
你的方法其实就是最经典的线性 DP。 状态转移方程：
dist[v]=(u,v)∈Emax​{dist[u]+weight(u,v)}
    Dijkstra 试图通过贪心策略来确定计算顺序（谁小先算谁），这在最长路径问题里是错的。
    拓扑排序 显式地给出了这个 DP 的正确计算顺序。只要按这个顺序算，方程就是成立的。
总结
你的方法之所以行，是因为： 拓扑排序消除了“后效性”。 当你处理节点 X 时，你的脚下踩着的是所有通向 X 的路径的完全体，你只要做一个简单的 max 比较，就能得到 X 的真理。这与权重是正还是负完全无关，只与流向有关。