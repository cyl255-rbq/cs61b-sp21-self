Integer a = 128;
Integer b = 128;
System.out.println(a == b);

这里返回false

这个问题的核心解释只有一个词：Integer Cache（整数缓存池）。
简短的解释如下：
1. == 对比的是什么？
对于对象（比如 Integer），== 对比的是 “内存地址”（是不是同一个对象实例），而不是 “数值”。
2. Java 的“偷懒”机制 (Integer Cache)
Java 为了节省内存和提升速度，默认把 -128 到 127 之间的整数所有的 Integer 对象都提前创建好并缓存起来了。
    当你使用 127 时： Java 会去缓存池里拿那个早就准备好的对象。 Integer a = 127; --> 拿到缓存里的对象 X Integer b = 127; --> 拿到缓存里的对象 X 因为是同一个对象，地址一样，所以 a == b 返回 True。
    当你使用 128 时： 128 超出了缓存范围 (-128 到 127)。Java 就不偷懒了，它会老老实实地创建新对象。 Integer a = 128; --> new Integer(128) (地址 A) Integer b = 128; --> new Integer(128) (地址 B) 虽然值一样，但它们是内存里两个独立的盒子，地址不同，所以 a == b 返回 False。
总结
这就是为什么 Horrible Steve 的代码在 127 之前都没事，一到 128 就崩了。
结论： 在 Java 中比较对象（Integer, String 等）的内容时，永远使用 .equals()，千万不要用 ==，除非你明确知道你在比地址。


总结来说，== 在 Java 中主要有 4 个 正确且常见的使用场景。
千万不要为了“小整数”去冒险用 ==，那是个坑！
以下是 == 的正确打开方式：
1. 基本数据类型 (Primitives) —— 最主要用途
这是 == 的绝对主场。对于 8 种基本类型，== 比较的就是值本身，完全没问题。
    int, long, short, byte
    char
    boolean
    float, double
Java
int a = 500;
int b = 500;
if (a == b) { ... } // ✅ 完全正确，int 比的就是数值
    注意： 这里的变量类型是 int (小写)，不是 Integer (大写)。
2. 判断是否为 null (Null Checks) —— 每天都在用
判断一个对象变量里是不是空的，必须用 ==。
Java
String s = null;
if (s == null) { ... } // ✅ 标准写法
3. 枚举类型 (Enums) —— 推荐用法
这是一个由于 Java 机制保证而非常安全的用法。因为枚举值（比如 Color.RED）在 JVM 里是全局唯一的（单例），所以用 == 既安全又快，而且还不怕空指针异常。
Java
Day today = Day.MONDAY;
// ✅ 推荐！比 today.equals(Day.MONDAY) 更好
if (today == Day.MONDAY) { 
    // ...
}
4. 判断“是否是同一个对象” (Object Identity) —— 特殊逻辑
当你真的不关心“内容是否一样”，只关心“这俩是不是同一个内存地址”时使用。
    场景举例： 比如你写了一个游戏，你想判断“攻击我的这个人，是不是我自己？”
    或者在实现 equals() 方法本身的时候，第一行通常都是用 == 来优化性能。
Java
@Override
public boolean equals(Object o) {
    // 1. 先判断内存地址，如果地址都一样，那肯定是同一个东西，直接返回 true
    if (this == o) return true;    
    // 2. 如果地址不一样，再费劲去比内容...
    if (o instanceof ...) { ... }
}
❌ 严重警告：关于“较小整数的判断”
你问到：“较小整数的判断……能用吗？”
答案是：尽量别用！
虽然你知道 -128 到 127 之间用 == 是 true，但这是一个**“实现细节” (Implementation Detail)，而不是你可以依赖的“特性”**。
如果你写出这样的代码：
Java
Integer x = 100;
Integer y = 100;
if (x == y) { ... } // 😱 虽然现在能跑通，但这是坏习惯！
万一哪天你的数据从 100 变成了 128，代码直接炸了。为了代码的健壮性，只要是 Integer（大写）对象，无论数字大小，一律用 .equals()。


枚举的一些解释
这确实稍微有点反直觉，因为我刚才还千叮咛万嘱咐“对象要用 .equals()”，结果转头就说“枚举（Enum）推荐用 ==”。
别晕，我用一个**“身份证”**的例子给你讲透为什么枚举是特例。
1. 什么是“全局唯一”（单例）？
想象一下，在这个世界上，“周一” (MONDAY) 这个概念是不是只有一个？
在 Java 的枚举（Enum）底层机制里，当你定义了：
Java
enum Day {
    MONDAY, TUESDAY, WEDNESDAY
}
Java 虚拟机（JVM）启动时，会偷偷地帮你做这样一件事（伪代码）：
    在内存里创建 唯一的一个 MONDAY 对象（假设内存地址是 0x111）。
    在内存里创建 唯一的一个 TUESDAY 对象（假设内存地址是 0x222）。
    绝对禁止你再 new 出第二个 MONDAY。
这意味着：不管你在程序的哪个角落用到 Day.MONDAY，你拿到的永远是内存地址 0x111 的那个同一个对象。
既然大家手里拿的都是同一个原件，那直接比地址（==）不就是最快、最准的吗？
2. 为什么说比 .equals() 更好？
主要有两个实实在在的好处：不崩（不报空指针） 和 类型安全。
好处 A：不怕空指针 (Null Safety) —— 最重要的原因
假设有一个变量 today，它还没有赋值，是 null。
    如果用 .equals() (会报错)：
    Java
Day today = null;
// 💥 崩了！因为 null 没有方法可以调用。
// 报错：NullPointerException
if (today.equals(Day.MONDAY)) { ... } 
如果用 == (很安全)：
Java
Day today = null;
// ✅ 安全！Java 允许 null 和对象比地址。
// 结果是 false，程序继续运行，不会崩。
if (today == Day.MONDAY) { ... }