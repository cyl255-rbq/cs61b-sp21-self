（c）Prim 算法和 Kruskal 算法有可能在同一个图 G 上找到不同的最小生成树（作为附加练习，构造一个符合这种情况的图！）。
给定任意边权重为整数的图 G，修改 G 以确保 Prim 算法和 Kruskal 算法始终找到相同的最小生成树 (MST)。你不能修改 Prim 算法或 Kruskal 算法。提示：参考 a 部分的第 1 个子部分。
切入点： 回顾 2(a) 的第一小题——如果图中的边权是唯一的，那么 MST 就是唯一的。既然 MST 唯一，无论用什么算法，找出来的结果必然一模一样。
    修改策略： 我们可以给每一条边增加一个微小的、唯一的偏移量（Offset）。
    约束条件：
        偏移量必须在 (0,1) 之间。因为原始权重是整数，增加一个小于 1 的小数不会改变原本权重的“大小排名”（例如权重 5 永远会小于权重 6，即使变成了 5.99 和 6.01）。
        每个偏移量必须是唯一的。
伪代码实现逻辑： 假设总共有 E 条边，我们让每条边加上的值分别为 0,1/E​,2/E​,…,(E−1)/E​。
E = number of edges in the graph
offset = 0
for edge in graph:
edge.weight += offset
offset += 1 / E