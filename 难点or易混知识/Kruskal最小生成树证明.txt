假设我们现在有一群村庄 {A,B,C,D}，Kruskal 算法正在给它们修路。经过几轮操作，Kruskal 选了三条边：(A,B)、(B,C) 和 (C,D)，把它们连成了一个“部落”（子森林）。
1. 设定反证法的“假设”
我们要证明 Kruskal 选出的这几条边是连接这四个村庄最省钱的方式（即 MST）。
反证假设： 假设 Kruskal 选出的这组路不是最省钱的。 这意味着，一定存在另一条我们“漏掉”的边（假设叫 ebetter​），如果我们用 ebetter​ 替换掉 Kruskal 选出的某条边（假设叫 ekruskal​），总花费会更低。
2. 逻辑推导：为什么这个“假设”立不住？
既然 ebetter​ 能让总花费更低，那唯一的可能就是：
    ebetter​ 的权重 < ekruskal​ 的权重
现在，我们回想一下 Kruskal 算法是怎么工作的：它是把全图所有的边按从小到大排好序，然后一条一条检查的。
    如果真的存在这条更便宜的 ebetter​： 那么在排序名单里，ebetter​ 一定排在 ekruskal​ 的前面。
    当算法处理到 ebetter​ 时：
        情况 A： 如果 ebetter​ 的两个端点当时还没连通，Kruskal 绝对不会放过它，一定会把它选进 MST 里。这与“我们漏掉了它”矛盾。
        情况 B： 如果 ebetter​ 没被选进去，唯一的理由是它会形成环。但形成环意味着它的两个端点已经通过更短的边连通了。既然已经有了更短的路径，那么用 ebetter​ 替换 ekruskal​ 反而会增加成本，这与“它更省钱”矛盾。
3. 结论
因为 Kruskal 算法是**“地毯式”搜索**——它从最便宜的边开始，只要不形成环就一定收编。
所以，当一个“部落”（子森林）形成时，它内部的每一条边都是在那个时刻能连接两个点的最廉价选择。如果存在更便宜的边，它早就被 Kruskal 抓走了，根本等不到更贵的边上场。