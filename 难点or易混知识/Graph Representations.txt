1. DFS 前序与后序 (DFS Pre-order & Post-order)
DFS 的核心逻辑是“尽可能深地探索”。该解释使用了栈（先进后出）来模拟递归过程，并配合一个**标记集（Marked Set）**防止重复访问。
核心规则：
    入栈即前序： 只要一个节点被压入栈，就立刻记录在 Pre-order 序列中。
    出栈即后序： 当一个节点的所有邻居都被访问完，将其从栈中弹出时，记录在 Post-order 序列中。
    字母表策略： 如果一个节点有多个邻居，按字母顺序（Lexicographically）选择下一个未标记的节点。
运行轨迹图解：
    A 入栈： Stack: [A], Pre: A。
    访问 B： Stack: [A, B], Pre: A, B。
    访问 C： Stack: [A, B, C], Pre: A, B, C。
    访问 F： Stack: [A, B, C, F], Pre: A, B, C, F。
    回溯： F 没有未访问邻居，F 出栈，Post: F。接着 C 和 B 也没有新邻居，依次出栈，Post: F, C, B。
    转向 D： 此时栈里只剩 A，A 还有一个邻居 D 没访问。D 入栈，Pre 加上 D。
    访问 E： E 入栈，Pre 加上 E。
    清空： E, D, A 依次出栈，Post 补全为 F, C, B, E, D, A。
    关于重启 (Restart)： 因为节点 G 是孤立的（在无向图中它与 A 不连通），如果算法要求遍历所有节点，则需要在发现栈空且仍有未标记节点时从 G “重启”。

2. BFS 层序遍历 (Breadth-First Search)
BFS 的核心逻辑是“先扫完周围的一圈”。它使用队列（先进先出）来管理访问顺序。
核心规则：
    入队即标记： 将起始点放入队列并标记。
    按“跳数”探索：
        首先记录距离起点 1 跳（1-hop）的所有邻居。
        然后再记录距离起点 2 跳的所有邻居。
    先进先出： 先进入队列的节点，其邻居也会先被处理。
运行轨迹图解：
    Start: 从 A 开始。
    1 跳邻居: A 连接 B 和 D。按字母序记录：A, B, D。
    2 跳邻居: * 检查 B 的邻居：发现 C（未标记），加入队列。
        检查 D 的邻居：发现 E 和 F（未标记），按字母序加入。
        结果序列：A, B, D, C, E, F。
    重启: 同样，如果需要遍历全图，最后会加上孤立的 G。