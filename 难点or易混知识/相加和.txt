给定一个整数 x 和一个包含 N 个不同整数的已排序数组 A，设计一个算法来查找是否存在索引 i 和 j 使得 A[i] + A[j] == x。
public static boolean findSum(int[] A, int x) {
	for (int i = 0; i < A.length; i++){
		for (int j = 0; j < A.length; j++) {
			if (A[i] + A[j] == x) return true;
		}
	}
	return false;
}
(a) How can we improve this solution? Hint: Does order matter here?
public static boolean findSumFaster(int[] A, int x){
	int left = 0;
	int right = A.length - 1;
	while (left <= right) {
		if (A[left] + A[right] == x) {
			return true;
		} else if (A[left] + A[right] < x) {
			left++;
		} else {
			right--;
		}
	}
	return false;
}
这种解法叫做 双指针法 (Two Pointer Approach)。
为什么你当时的思路卡住了？
你当时的思路是：
    "首尾相加，然后每次首尾都 +1" (意思是左边往右移，右边往左移？)
这里的逻辑漏洞在于：如果你同时移动两个指针，你就无法确定总和是变大还是变小了。
    左边向右移（数值变大）
    右边向左移（数值变小）
    如果你同时做这两个动作，总和可能变大，也可能变小，你就失去了对结果的“控制权”。
正确的逻辑：一次只动一边

你想到二叉树其实也不算完全错，因为“有序”这个条件很容易让人联想到 二分查找 (Binary Search)。
如果你用二分查找思路做，解法是这样的：
    遍历每一个数 A[i]。
    在剩下的数组里用二分查找寻找 x - A[i]。
    这种方法的时间复杂度是 Θ(NlogN)。
