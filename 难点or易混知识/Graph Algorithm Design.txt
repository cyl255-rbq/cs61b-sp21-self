对于以下每种情况，请简要描述一种在无向连通图 G 中寻找最小生成树的算法。
（a）如果所有边的权重均为 1。提示：运行时间为 O(V+E)
这里的关键思想是，任何连接所有节点的树都是MST。我们 
可以运行DFS并获取DFS树。你也可以带一棵BFS树，或者跑步 
Prim的算法使用队列或堆栈而不是优先级队列（这将 
相当于BFS/DFS）。不幸的是，经过修改的Kruskal将稍微 
速度较慢，因为即使我们不需要对边进行排序，联合查找操作 
将需要额外的时间。
(b) 如果所有边的权重均为 1 或 2。提示：使用你在 (a) 部分中的算法。
我们首先移除所有权重为二的边,然后我们进行深度优先搜索（DFS）,
这样就得到一堆小的连通分量,每个连通分量你们可以把它们想象成一个迷你最小生成树（MST）
,所以通过这些迷你 MST,我们需要将迷你 MSTS 连接起来,为此，我们将创建一个新图
在新图中，一个节点 a 代表之前图中的一个连通分量,因此，考虑到那个连通分量,
我们将做的是重新加入权重为二的边,如果有多余的权重为二的边，出于简化的考虑就没有必要添加它
然后我们将使用这个新图重新运行深度优先搜索（DFS）,我们将获得一部分权重为二的边的子集
然后我们将把它添加回之前的图中,这样我们就得到了最终的最小生成树


1. 为什么这个思路是成立的？（贪心的本质）
这个算法其实就是 Kruskal 算法的“大步走”版本。
    Kruskal 告诉我们： 你应该先看最便宜的边。
    这道题只有两种价格： 1块钱和2块钱。
    策略： 既然1块钱的边最划算，那我就先把所有1块钱的边全用上（只要不形成环）。用完之后，图会变成几个互不相连的“孤岛”。这时候，我再拿2块钱的边去把这些“岛屿”连起来。
2. 为什么你觉得“写不出算法”？
你可能觉得“把连通分量变成一个超级节点”这个动作太抽象，很难用代码实现。其实，在实际编程中，我们根本不需要真的去“创建一个新图”，只需要利用 并查集（Union-Find） 或者 染色标记 就能完成：
    第一阶段： 遍历所有权重为 1 的边 (u,v)。如果 u 和 v 还没连通，就把它们连起来。
    第二阶段： 遍历所有权重为 2 的边 (u,v)。如果此时 u 和 v 还在不同的“岛屿”上，就选这条边把两个岛连起来。
看，这其实就是最标准的 Kruskal，只是因为权重只有两种，我们连“排序”这一步都省了！ 直接先扫描一遍 1，再扫描一遍 2，复杂度是完美的 O(V+E)。
3. 如何培养这种“想不到”的直觉？
当你以后遇到“离散权重”（比如权重只有几种固定的数字）或者“特殊限制”的题目时，可以尝试这个思维公式：
    “如果我只处理最简单的那部分，会发生什么？”
    这道题： 如果我只看权重 1 的边，图会变成什么样？（变成了几个连通块）
    下一步： 我怎么把这些块连起来？（用权重 2 的边）
    结果： 两个 O(V+E) 的操作加起来，依然是 O(V+E)。
