这是一个非常经典且容易犯的错误，叫做 **“变量遮蔽” (Shadowing)**。
简单来说：**你在内部类上再次写 `<Z>`，就好比儿子非要给自己起一个和爸爸一模一样的名字，导致家里人喊名字时乱套了。**
我来把这个逻辑拆解清楚：
### 1\. 场景还原：爸爸和儿子的关系
假设你的外部类（爸爸）叫 `Map`，它定义了一个泛型 `Z`。
```java
// 外部类定义了泛型 Z (我们叫它 Z_爸爸)
public class Map<Z> {  
    // ... 内部代码 ...
}
```
现在你要写一个非静态内部类（住在爸爸家里的儿子）叫 `MapWizard`。
#### ✅ 正确写法（儿子直接用爸爸的钱）
因为 `MapWizard` 是非静态内部类，它天生就能访问外部类的所有东西，包括泛型 `Z`。
```java
// 正确：类名后面不加 <Z>
private class MapWizard implements Iterator<Z> { 
    // 这里没加 <Z>，说明我没有创造新变量。
    // 这里的 implements Iterator<Z> 用的是“Z_爸爸”。 
    public Z next() { return ...; } // 返回的是“Z_爸爸”
}
```
  * **结果**：父子同心。爸爸说是 String，儿子用的就是 String。
#### ❌ 错误写法（儿子非要自己印假钞）
如果你在类名后面加了 `<Z>`：
```java
// 错误：类名后面加了 <Z>
private class MapWizard<Z> implements Iterator<Z> {
    // 完蛋了！你在内部类里【重新声明】了一个全新的泛型变量。
    // 虽然它也叫 Z，但它跟外面的 Z 没有任何关系！
    // 我们叫它 “Z_儿子”。 
    public Z next() { return ...; } // 这里返回的是“Z_儿子”
}
```
  * **结果**：
      * 外部类说：`Z` 是 **String**。
      * 内部类说：我的 `Z` 是 **Object** (或者其他东西)。
      * **编译器报错**：`Type Z#1 is not compatible with Type Z#2`。意思是：你虽然都叫 Z，但一个是爸爸定义的，一个是儿子定义的，我不认为它们是同一个类型。
### 2\. 为什么 `implements` 后面要加，而类名后面不用？
这就回到了我们之前讨论的 **“定义（声明）”** vs **“使用”** 的区别。
```java
//       (A) 定义处                (B) 使用处
private class MapWizard      implements Iterator<Z> 
```
  * **(A) 类名后面**：这是**定义变量**的地方。
      * 如果你写 `<Z>`，就是在**创造**一个新的泛型变量。
      * 如果你不写，就是在**默认**使用外部类的泛型环境。
  * **(B) 接口后面**：这是**使用变量**的地方。
      * 你必须填上一个具体的类型。
      * 这里填 `Z`，意思是：“我要实现的迭代器，是专门处理外部类那个 `Z` 类型的。”
### 3\. 什么时候内部类【需要】加 `<Z>`？
只有一种情况：**当内部类是 `static` (静态) 的时候。**
如果 `MapWizard` 是 `static` 的，它就相当于搬出去了，不再依附于外部类的实例，也就看不到外部类的 `Z` 了。这时候它必须自力更生，自己定义自己的泛型。
### 总结
  * **非静态内部类 (private class Inner)**：像住在家里。**不要**在类名后重新声明 `<T>`，直接用爸爸的。
  * **静态嵌套类 (private static class Inner)**：像搬出去住。**必须**在类名后自己声明 `<T>`，因为你看不到爸爸的。
**你遇到的报错 `K#1 is not compatible with K#2`，翻译过来就是：“爸爸的 K 和儿子的 K 虽然名字一样，但它们不是同一个东西，无法匹配。”**