当有多个同名方法都能匹配你的参数时，Java 编译器遵循一个黄金法则：“最具体匹配原则”（Most Specific Match）。
备选方案 1：method(C c) —— 这是一个宽泛的匹配（只要是 C 家族的都能进）。
    备选方案 2：method(SubC s) —— 这是一个精确的、具体的匹配（只有 C 的子类能进）。
    你的调用：method(new SubC())。
编译器会想：“虽然这两个方法都能处理这个对象，但备选方案 2 写得更具体、更针对这个类型，所以我就选它。
假设 C 是 Animal，C 的子类是 Dog。
Java
public class Tester {
    // 方法 1：接受父类
    public void test(Animal a) {
        System.out.println("我是处理 Animal 的方法");
    }
    // 方法 2：接受子类
    public void test(Dog d) {
        System.out.println("我是处理 Dog 的方法");
    }
    public static void main(String[] args) {
        Tester t = new Tester();
        Dog myDog = new Dog();
        // 调用
        t.test(myDog); 
    }
}
输出结果：
Plaintext
我是处理 Dog 的方法
一个巨大的陷阱（千万注意！）
我们在前几轮对话中反复强调过：重载（Overloading）看静态类型，重写（Override）看动态类型。
上面那个例子之所以调用 test(Dog)，是因为 myDog 变量的静态类型也是 Dog。
如果你这样写，结果就会变：
Java
// 静态类型是 Animal，动态类型是 Dog
Animal a = new Dog(); 
t.test(a); // <--- 这里会调用哪个？
结果是："我是处理 Animal 的方法" (即调用第一个方法)。
为什么？ 因为 重载（Overloading） 的选择是在 编译阶段 就定死的。
    编译器看到变量 a 的标签（静态类型）是 Animal。
    编译器根本不关心 a 实际上是一只狗。
    编译器直接把这个调用绑定到了 test(Animal) 上。
总结
    如果你直接传入子类对象（或静态类型为子类的变量）：调用最具体的那个（子类参数的方法）。
    如果你传入静态类型为父类的变量（即使本质是子类）：调用父类参数的方法。
第一步：编译器的“预测”？（其实是“锁定签名”）
编译器不是在预测运行时会发生什么（因为它预测不到，也不关心）。 编译器是在做**“资格审查”和“锁定目标”**。
当你写 a.method(b) 时，编译器只看 a 和 b 的静态类型。它会做两件事：
    查户口（Check Access）：
        编译器看 a 的静态类型（比如 Animal）。
        它去查 Animal 类里有没有一个叫 method 的方法。
        如果没有 -> 报错。
        如果有 -> 通过。
    锁定签名（Lock Signature）——这是重点！
        如果 Animal 类里有好几个叫 method 的（重载），编译器会根据参数 b 的静态类型，当场决定我们要调用哪一个方法签名。
        比如它决定了：“好，我锁定了，我们要调用的就是 method(Animal x) 这一款。”
        注意：这一步在编译生成 .class 文件时就写死了。
修正你的理解： 编译器不是“预测”能不能跑通，而是根据静态标签，把要调用的“方法名”和“参数列表”给定死了。
第二步：运行时的“动态选择”？（其实是“填空题”）
程序跑起来了，JVM（Java 虚拟机）拿到编译器传给它的指令：
    指令：请对变量 a 调用 method(Animal x) 这一款方法。
这时候，JVM 开始看动态类型（本质）：
    看对象是谁：JVM 发现 a 指向的内存里，真实对象是一只 Dog。
    找代码（Dynamic Binding）：
        JVM 去 Dog 类里找：“你有重写（Override）过 method(Animal x) 吗？”
        如果重写了 -> 执行 Dog 的代码。
        如果没重写 -> 去 Dog 的爸爸那里找，执行爸爸的代码。
修正你的理解： 运行时并不是“重新选择调用哪个方法”（它不能改变参数列表），而是**“决定去谁的肚子里执行这段代码”**。
总结：两步走的终极模型
请记住这个**“点菜”**的比喻：
1. 编译时（看菜单点菜）—— 静态类型决定
    场景：你在看菜单（父类 Animal 的定义）。
    动作：你指着菜单说：“我要一份宫保鸡丁（方法签名）。”
    重载（Overloading）：如果菜单上有“微辣宫保鸡丁”和“特辣宫保鸡丁”，你根据你的口味（参数的静态类型）选定了要“微辣”的那一款。
    结果：订单上写死了 “微辣宫保鸡丁”。你不能改了。
2. 运行时（厨师做菜）—— 动态类型决定
    场景：订单传到了后厨（内存对象）。
    动作：看今天是哪个厨师（动态类型）当班。
    重写（Override）：
        如果是 王大厨（Dog）：他做的微辣宫保鸡丁可能加了花生酱（重写的逻辑）。
        如果是 李大厨（Cat）：他做的微辣宫保鸡丁可能加了薄荷（另一套重写的逻辑）。
    结果：你吃到的具体味道取决于厨师，但菜名（微辣宫保鸡丁）在点菜时就定好了。
回答你之前的问题
回到刚才那个“接收子类参数”的问题：
Java
// 方法中有 A(C c) 和 A(SubC s)
method(new SubC()); 
    编译时（预测/锁定）：
        编译器看参数是 new SubC()。
        编译器想：“这个参数符合 A(SubC s) 的要求，而且比 A(C c) 更具体。”
        锁定：订单上写死 “调用 A(SubC s)”。
    运行时（动态选择）：
        JVM 拿到订单：“好，我要执行 A(SubC s)。”
        JVM 去当前对象的类里找这段代码执行。
所以，对于重载（Overloading），“预测”即“最终决定”。运行时的动态类型没有任何发言权去改变参数的选择。